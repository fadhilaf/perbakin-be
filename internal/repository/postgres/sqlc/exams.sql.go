// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: exams.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createExam = `-- name: CreateExam :one
INSERT INTO exams (super_id, name, location, organizer, begin, finish)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, super_id, name, location, organizer, begin, finish, active, created_at, updated_at
`

type CreateExamParams struct {
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

// untuk membuat exam (super role)
func (q *Queries) CreateExam(ctx context.Context, arg CreateExamParams) (Exam, error) {
	row := q.db.QueryRow(ctx, createExam,
		arg.SuperID,
		arg.Name,
		arg.Location,
		arg.Organizer,
		arg.Begin,
		arg.Finish,
	)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.SuperID,
		&i.Name,
		&i.Location,
		&i.Organizer,
		&i.Begin,
		&i.Finish,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteExam = `-- name: DeleteExam :exec
DELETE FROM exams WHERE id = $1
`

// untuk menghapus exam (super role)
func (q *Queries) DeleteExam(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteExam, id)
	return err
}

const getAllExams = `-- name: GetAllExams :many
SELECT exams.name, users.name as super, location, organizer, begin, finish, active
FROM exams JOIN supers ON exams.super_id = supers.id 
JOIN users ON supers.user_id = users.id
`

type GetAllExamsRow struct {
	Name      string
	Super     string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
	Active    bool
}

// untuk mengambil seluruh exam (super role)
func (q *Queries) GetAllExams(ctx context.Context) ([]GetAllExamsRow, error) {
	rows, err := q.db.Query(ctx, getAllExams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllExamsRow
	for rows.Next() {
		var i GetAllExamsRow
		if err := rows.Scan(
			&i.Name,
			&i.Super,
			&i.Location,
			&i.Organizer,
			&i.Begin,
			&i.Finish,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExamById = `-- name: GetExamById :one
SELECT id, super_id, name, location, organizer, begin, finish, active, created_at, updated_at 
FROM exams 
WHERE id = $1
`

// untuk mengambil satu data exam (super role)
func (q *Queries) GetExamById(ctx context.Context, id pgtype.UUID) (Exam, error) {
	row := q.db.QueryRow(ctx, getExamById, id)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.SuperID,
		&i.Name,
		&i.Location,
		&i.Organizer,
		&i.Begin,
		&i.Finish,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExamByName = `-- name: GetExamByName :one
SELECT id
FROM exams 
WHERE name = $1
`

// untuk mengambil exam berdasarkan nama untuk cek nama sudah dipakai blum (super role)
func (q *Queries) GetExamByName(ctx context.Context, name string) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getExamByName, name)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getExamRelationById = `-- name: GetExamRelationById :one
SELECT id, super_id 
FROM exams 
WHERE id = $1
`

type GetExamRelationByIdRow struct {
	ID      pgtype.UUID
	SuperID pgtype.UUID
}

// untuk mengambil data relasi exam (all role)
func (q *Queries) GetExamRelationById(ctx context.Context, id pgtype.UUID) (GetExamRelationByIdRow, error) {
	row := q.db.QueryRow(ctx, getExamRelationById, id)
	var i GetExamRelationByIdRow
	err := row.Scan(&i.ID, &i.SuperID)
	return i, err
}

const getExamsBySuperId = `-- name: GetExamsBySuperId :many
SELECT id, name, location, organizer, begin, finish, active
FROM exams 
WHERE super_id = $1
`

type GetExamsBySuperIdRow struct {
	ID        pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
	Active    bool
}

// untuk mengambil seluruh exam (super role)
func (q *Queries) GetExamsBySuperId(ctx context.Context, superID pgtype.UUID) ([]GetExamsBySuperIdRow, error) {
	rows, err := q.db.Query(ctx, getExamsBySuperId, superID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExamsBySuperIdRow
	for rows.Next() {
		var i GetExamsBySuperIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Location,
			&i.Organizer,
			&i.Begin,
			&i.Finish,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExam = `-- name: UpdateExam :one
UPDATE exams 
SET 
  name = $2, 
  location = $3, 
  organizer = $4, 
  begin = $5, 
  finish = $6, 
  updated_at = NOW()
WHERE id = $1
RETURNING id, super_id, name, location, organizer, begin, finish, created_at, updated_at
`

type UpdateExamParams struct {
	ID        pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

type UpdateExamRow struct {
	ID        pgtype.UUID
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

// untuk memperbarui exam (super role)
func (q *Queries) UpdateExam(ctx context.Context, arg UpdateExamParams) (UpdateExamRow, error) {
	row := q.db.QueryRow(ctx, updateExam,
		arg.ID,
		arg.Name,
		arg.Location,
		arg.Organizer,
		arg.Begin,
		arg.Finish,
	)
	var i UpdateExamRow
	err := row.Scan(
		&i.ID,
		&i.SuperID,
		&i.Name,
		&i.Location,
		&i.Organizer,
		&i.Begin,
		&i.Finish,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateExamStatus = `-- name: UpdateExamStatus :one
UPDATE exams 
  SET active = CASE 
    WHEN active = true 
      THEN false 
      ELSE true 
    END, 
  updated_at = NOW()
WHERE id = $1
RETURNING active
`

// untuk mengubah status exam (super role)
func (q *Queries) UpdateExamStatus(ctx context.Context, id pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, updateExamStatus, id)
	var active bool
	err := row.Scan(&active)
	return active, err
}
