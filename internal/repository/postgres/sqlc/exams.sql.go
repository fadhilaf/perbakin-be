// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: exams.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createExam = `-- name: CreateExam :one
INSERT INTO exams (super_id, name, location, organizer, begin, finish)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, super_id, name, location, organizer, begin, finish
`

type CreateExamParams struct {
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

type CreateExamRow struct {
	ID        pgtype.UUID
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

func (q *Queries) CreateExam(ctx context.Context, arg CreateExamParams) (CreateExamRow, error) {
	row := q.db.QueryRow(ctx, createExam,
		arg.SuperID,
		arg.Name,
		arg.Location,
		arg.Organizer,
		arg.Begin,
		arg.Finish,
	)
	var i CreateExamRow
	err := row.Scan(
		&i.ID,
		&i.SuperID,
		&i.Name,
		&i.Location,
		&i.Organizer,
		&i.Begin,
		&i.Finish,
	)
	return i, err
}

const deleteExam = `-- name: DeleteExam :exec
DELETE FROM exams WHERE id = $1
`

func (q *Queries) DeleteExam(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteExam, id)
	return err
}

const getAllExams = `-- name: GetAllExams :many
SELECT id, super_id, name, location, organizer, begin, finish FROM exams
`

type GetAllExamsRow struct {
	ID        pgtype.UUID
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

func (q *Queries) GetAllExams(ctx context.Context) ([]GetAllExamsRow, error) {
	rows, err := q.db.Query(ctx, getAllExams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllExamsRow
	for rows.Next() {
		var i GetAllExamsRow
		if err := rows.Scan(
			&i.ID,
			&i.SuperID,
			&i.Name,
			&i.Location,
			&i.Organizer,
			&i.Begin,
			&i.Finish,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExamById = `-- name: GetExamById :one
SELECT id, super_id, name, location, organizer, begin, finish 
FROM exams 
WHERE id = $1
`

type GetExamByIdRow struct {
	ID        pgtype.UUID
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

func (q *Queries) GetExamById(ctx context.Context, id pgtype.UUID) (GetExamByIdRow, error) {
	row := q.db.QueryRow(ctx, getExamById, id)
	var i GetExamByIdRow
	err := row.Scan(
		&i.ID,
		&i.SuperID,
		&i.Name,
		&i.Location,
		&i.Organizer,
		&i.Begin,
		&i.Finish,
	)
	return i, err
}

const getExamByName = `-- name: GetExamByName :one
SELECT id, super_id, name, location, organizer, begin, finish 
FROM exams 
WHERE name = $1
`

type GetExamByNameRow struct {
	ID        pgtype.UUID
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

func (q *Queries) GetExamByName(ctx context.Context, name string) (GetExamByNameRow, error) {
	row := q.db.QueryRow(ctx, getExamByName, name)
	var i GetExamByNameRow
	err := row.Scan(
		&i.ID,
		&i.SuperID,
		&i.Name,
		&i.Location,
		&i.Organizer,
		&i.Begin,
		&i.Finish,
	)
	return i, err
}

const getExamBySuperId = `-- name: GetExamBySuperId :many
SELECT id, super_id, name, location, organizer, begin, finish 
FROM exams 
WHERE super_id = $1
`

type GetExamBySuperIdRow struct {
	ID        pgtype.UUID
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

func (q *Queries) GetExamBySuperId(ctx context.Context, superID pgtype.UUID) ([]GetExamBySuperIdRow, error) {
	rows, err := q.db.Query(ctx, getExamBySuperId, superID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExamBySuperIdRow
	for rows.Next() {
		var i GetExamBySuperIdRow
		if err := rows.Scan(
			&i.ID,
			&i.SuperID,
			&i.Name,
			&i.Location,
			&i.Organizer,
			&i.Begin,
			&i.Finish,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExam = `-- name: UpdateExam :one
UPDATE exams 
SET 
  name = $2, 
  location = $3, 
  organizer = $4, 
  begin = $5, 
  finish = $6 
WHERE id = $1
RETURNING id, super_id, name, location, organizer, begin, finish
`

type UpdateExamParams struct {
	ID        pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

type UpdateExamRow struct {
	ID        pgtype.UUID
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

func (q *Queries) UpdateExam(ctx context.Context, arg UpdateExamParams) (UpdateExamRow, error) {
	row := q.db.QueryRow(ctx, updateExam,
		arg.ID,
		arg.Name,
		arg.Location,
		arg.Organizer,
		arg.Begin,
		arg.Finish,
	)
	var i UpdateExamRow
	err := row.Scan(
		&i.ID,
		&i.SuperID,
		&i.Name,
		&i.Location,
		&i.Organizer,
		&i.Begin,
		&i.Finish,
	)
	return i, err
}
