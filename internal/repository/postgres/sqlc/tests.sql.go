// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: tests.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTest = `-- name: CreateTest :one
INSERT INTO tests (super_id, name, location, organizer, begin, finish)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, super_id, name, location, organizer, begin, finish
`

type CreateTestParams struct {
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

type CreateTestRow struct {
	ID        pgtype.UUID
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

func (q *Queries) CreateTest(ctx context.Context, arg CreateTestParams) (CreateTestRow, error) {
	row := q.db.QueryRow(ctx, createTest,
		arg.SuperID,
		arg.Name,
		arg.Location,
		arg.Organizer,
		arg.Begin,
		arg.Finish,
	)
	var i CreateTestRow
	err := row.Scan(
		&i.ID,
		&i.SuperID,
		&i.Name,
		&i.Location,
		&i.Organizer,
		&i.Begin,
		&i.Finish,
	)
	return i, err
}

const deleteTest = `-- name: DeleteTest :exec
DELETE FROM tests WHERE id = $1
`

func (q *Queries) DeleteTest(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTest, id)
	return err
}

const getAllTests = `-- name: GetAllTests :many
SELECT id, super_id, name, location, organizer, begin, finish FROM tests
`

type GetAllTestsRow struct {
	ID        pgtype.UUID
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

func (q *Queries) GetAllTests(ctx context.Context) ([]GetAllTestsRow, error) {
	rows, err := q.db.Query(ctx, getAllTests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTestsRow
	for rows.Next() {
		var i GetAllTestsRow
		if err := rows.Scan(
			&i.ID,
			&i.SuperID,
			&i.Name,
			&i.Location,
			&i.Organizer,
			&i.Begin,
			&i.Finish,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTest = `-- name: GetTest :one
SELECT id, super_id, name, location, organizer, begin, finish 
FROM tests 
WHERE id = $1
`

type GetTestRow struct {
	ID        pgtype.UUID
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

func (q *Queries) GetTest(ctx context.Context, id pgtype.UUID) (GetTestRow, error) {
	row := q.db.QueryRow(ctx, getTest, id)
	var i GetTestRow
	err := row.Scan(
		&i.ID,
		&i.SuperID,
		&i.Name,
		&i.Location,
		&i.Organizer,
		&i.Begin,
		&i.Finish,
	)
	return i, err
}

const getTestByName = `-- name: GetTestByName :one
SELECT id, super_id, name, location, organizer, begin, finish 
FROM tests 
WHERE name = $1
`

type GetTestByNameRow struct {
	ID        pgtype.UUID
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

func (q *Queries) GetTestByName(ctx context.Context, name string) (GetTestByNameRow, error) {
	row := q.db.QueryRow(ctx, getTestByName, name)
	var i GetTestByNameRow
	err := row.Scan(
		&i.ID,
		&i.SuperID,
		&i.Name,
		&i.Location,
		&i.Organizer,
		&i.Begin,
		&i.Finish,
	)
	return i, err
}

const getTestsBySuperId = `-- name: GetTestsBySuperId :many
SELECT id, super_id, name, location, organizer, begin, finish 
FROM tests 
WHERE super_id = $1
`

type GetTestsBySuperIdRow struct {
	ID        pgtype.UUID
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

func (q *Queries) GetTestsBySuperId(ctx context.Context, superID pgtype.UUID) ([]GetTestsBySuperIdRow, error) {
	rows, err := q.db.Query(ctx, getTestsBySuperId, superID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestsBySuperIdRow
	for rows.Next() {
		var i GetTestsBySuperIdRow
		if err := rows.Scan(
			&i.ID,
			&i.SuperID,
			&i.Name,
			&i.Location,
			&i.Organizer,
			&i.Begin,
			&i.Finish,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTest = `-- name: UpdateTest :one
UPDATE tests 
SET 
  super_id = $1, 
  name = $2, 
  location = $3, 
  organizer = $4, 
  begin = $5, 
  finish = $6 
WHERE id = $7 
RETURNING id, super_id, name, location, organizer, begin, finish
`

type UpdateTestParams struct {
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
	ID        pgtype.UUID
}

type UpdateTestRow struct {
	ID        pgtype.UUID
	SuperID   pgtype.UUID
	Name      string
	Location  string
	Organizer string
	Begin     pgtype.Date
	Finish    pgtype.Date
}

func (q *Queries) UpdateTest(ctx context.Context, arg UpdateTestParams) (UpdateTestRow, error) {
	row := q.db.QueryRow(ctx, updateTest,
		arg.SuperID,
		arg.Name,
		arg.Location,
		arg.Organizer,
		arg.Begin,
		arg.Finish,
		arg.ID,
	)
	var i UpdateTestRow
	err := row.Scan(
		&i.ID,
		&i.SuperID,
		&i.Name,
		&i.Location,
		&i.Organizer,
		&i.Begin,
		&i.Finish,
	)
	return i, err
}
